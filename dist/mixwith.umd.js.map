{"version":3,"file":"mixwith.umd.js","sources":["../src/mixwith.ts"],"sourcesContent":["'use strict'\n\nexport type Function<A = any> = (...args: any[]) => A\nexport type Constructor<A = {}> = new (...args: any[]) => A\nexport type MixinType<T extends Function> = InstanceType<ReturnType<T>>\nexport type MixinParameters<T extends (...args: any) => any> = T extends (superclass: any, ...args: infer P) => any ? P : never\n\nexport type MixWith<T extends Constructor, U extends Function[]> = U extends [infer A extends Function, ...infer B extends Function[]]\n  ? T & MixWith<ReturnType<A>, B>\n  : T\n\nexport const _cachedApplicationRef = Symbol('_cachedApplicationRef')\nexport const _mixinRef = Symbol('_mixinRef')\nexport const _originalMixin = Symbol('_originalMixin')\n\ntype WithOriginal = Function & { [_originalMixin]: Function }\n\n/**\n * Sets the prototype of mixin to wrapper so that properties set on mixin are\n * inherited by the wrapper.\n *\n * This is needed in order to implement @@hasInstance as a decorator function.\n */\nexport const wrap = <T extends WithOriginal>(mixin: T, wrapper: Function): T => {\n  return Object.setPrototypeOf(wrapper, mixin)\n}\n\n/**\n * Decorates mixin so that it caches its applications. When applied multiple\n * times to the same superclass, mixin will only create one subclass and\n * memoize it.\n */\nexport const Cached = <TMixin extends WithOriginal, TSuperclass extends Constructor>(\n  mixin: TMixin & { [_cachedApplicationRef]?: keyof TSuperclass }\n): TMixin =>\n  wrap(mixin, function (superclass: TSuperclass) {\n    // Get or create a symbol used to look up a previous application of mixin\n    // to the class. This symbol is unique per mixin definition, so a class will have N\n    // applicationRefs if it has had N mixins applied to it. A mixin will have\n    // exactly one _cachedApplicationRef used to store its applications.\n    let applicationRef = mixin[_cachedApplicationRef]\n    if (!applicationRef) {\n      applicationRef = mixin[_cachedApplicationRef] = Symbol(mixin.name) as keyof TSuperclass\n    }\n    // Look up an existing application of `mixin` to `c`, return it if found.\n    if (Object.hasOwn(superclass, applicationRef)) {\n      return superclass[applicationRef] as Constructor\n    }\n    // Apply the mixin\n    const application: Constructor = mixin(superclass)\n    // Cache the mixin application on the superclass\n    Object.defineProperty(superclass, applicationRef, { value: application })\n    return application\n  })\n\n/**\n * Returns `true` if `o` has an application of `mixin` on its prototype chain.\n *\n * @example\n * hasMixin(superclass.prototype, mixin)\n */\nexport const hasMixin = <T extends WithOriginal>(o: any, mixin: T): boolean => {\n  while (o != null) {\n    if (o[_mixinRef] === mixin[_originalMixin]) {\n      return true\n    }\n    o = Object.getPrototypeOf(o)\n  }\n  return false\n}\n\n/**\n * Adds @@hasInstance (ES2015 instanceof support) to mixin.\n * Note: @@hasInstance is not supported in any browsers yet.\n */\nexport const HasInstance = <T extends WithOriginal>(mixin: T): T => {\n  if (!Object.hasOwn(mixin[_originalMixin], Symbol.hasInstance)) {\n    Object.defineProperty(mixin[_originalMixin], Symbol.hasInstance, {\n      value: function (o: unknown) {\n        return hasMixin(o, mixin)\n      }\n    })\n  }\n  return mixin\n}\n\n/**\n * Decorates `mixin` so that it only applies if it's not already on the prototype chain.\n */\nexport const DeDupe = <T extends WithOriginal>(mixin: T): T =>\n  wrap(mixin, function <S extends Constructor>(superclass: S) {\n    return hasMixin(superclass.prototype, mixin) ? superclass : mixin(superclass)\n  })\n\n/**\n * A basic mixin decorator that sets up a reference from mixin applications\n * to the mixin definition for use by other mixin decorators.\n */\nexport const BareMixin = <T extends WithOriginal>(mixin: T): T =>\n  wrap(mixin, function <S extends Constructor>(superclass: S) {\n    // Apply the mixin\n    const application = mixin(superclass)\n\n    // Attach a reference from mixin application to wrapped mixin for RTTI\n    // mixin[@@hasInstance] should use this.\n    application.prototype[_mixinRef] = (mixin as WithOriginal)[_originalMixin]\n    return application\n  })\n\n/**\n * @param {T} mixin\n */\nexport const Mixin = <T extends Function>(mixin: T): T => Cached(DeDupe(HasInstance(BareMixin(Object.assign(mixin, {[_originalMixin]: mixin})))))\n\nexport class MixinBuilder<TSuperClass extends Constructor> {\n  private readonly superclass: TSuperClass\n\n  constructor (superclass: TSuperClass) {\n    this.superclass = superclass\n  }\n\n  with<A extends Function[]> (...args: A): MixWith<TSuperClass, A> {\n    return Array.from(args).reduce((c, m) => m(c), this.superclass) as MixWith<TSuperClass, A>\n  }\n}\n\n/**\n * \n * @param superclass \n * @returns \n * @example\n * class Base {}\n * \n * const Mixin1 = Mixin(<T extends Constructor>(superclass: T) => class extends superclass { name = \"\" })\n * const Mixin2 = Mixin(<T extends Constructor>(superclass: T) => class extends superclass { id = \"\" })\n * \n * class MyClass extends mix(Base).with(Mixin1, Mixin2) {}\n * \n * console.log(new MyClass()) // MyClass { name: '', id: '' }\n */\nexport const mix = <T extends Constructor> (superclass: T): MixinBuilder<T> => new MixinBuilder(superclass)"],"names":[],"mappings":"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"}